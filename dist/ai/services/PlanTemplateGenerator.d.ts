import { UserMemoryProfile, MemoryDrivenPlanTemplate } from "../smart-memory";
import { PlanTemplateService } from "./PlanTemplateService";
import { PlanTemplate, UserPlanContext, PlanGenerationCostMeta } from "../interfaces/PlanTemplates";
import { VisualizationService } from "./VisualizationService";
import { PlanLibraryService } from "./PlanLibraryService";
export declare class PlanTemplateGenerator {
    private templateService;
    private visualizationService;
    private planLibrary;
    constructor(templateService: PlanTemplateService, visualizationService: VisualizationService, planLibrary: PlanLibraryService);
    generateWorkoutPlan(userProfile: UserMemoryProfile, context: UserPlanContext): Promise<{
        plan: PlanTemplate;
        costs: PlanGenerationCostMeta;
        visualizations: any;
        metrics: {
            variablesConsidered: number;
            simulatedProfiles: number;
            adaptationPoints: number;
        };
    }>;
    private determineUserLevel;
    private determineUserGoal;
    private determineSplitType;
    private calculateConsistentTrainingMonths;
    private calculateTrainingMetrics;
    private calculateWeeklyAdherence;
    private calculateCompletionRate;
    private calculateAverageRPE;
    private calculateVolumeCompletion;
    private calculateStrengthProgress;
    private calculateEnduranceProgress;
    private convertBaseToTemplate;
    private countVariablesConsidered;
    private countAdaptationPoints;
    private generateNewPlan;
    private adjustPlanWithReusableComponents;
    generatePlanTemplate(profile: UserMemoryProfile, goal: string, timeframe: string): Promise<MemoryDrivenPlanTemplate>;
    private generateTemplateId;
    private analyzeWorkoutTypePreferences;
    private analyzeWorkoutType;
    private determineOptimalRotation;
    private determineProgressionStyle;
    private determineRecoveryApproach;
    private determineMotivationIntegration;
    private generateCustomizations;
    private calculateSuccessMetrics;
    private generateMemoryReasoning;
    private calculateOptimalFrequency;
    private calculateOptimalDuration;
    private calculateOptimalIntensity;
    private generateTypeReasoning;
    private calculateTypeSuccessRate;
    private analyzeRotationPreference;
    private generateRotationPattern;
    private determineVarietyPreference;
    private generateRotationReasoning;
    private analyzeProgressionStyle;
    private determineProgressionSpeed;
    private calculateDeloadFrequency;
    private generateProgressionReasoning;
    private analyzeRecoveryPreference;
    private calculateRecoveryFrequency;
    private determineRecoveryMethods;
    private generateRecoveryReasoning;
    private identifyEffectiveTriggers;
    private determineMotivationFrequency;
    private analyzeMotivationType;
    private generateMotivationReasoning;
    private generateExerciseSubstitutions;
    private calculateIntensityAdjustments;
    private determineTimingPreferences;
    private identifyMotivationalElements;
    private predictAdherence;
    private predictSatisfaction;
    private predictEffectiveness;
    private calculatePredictionConfidence;
    private explainExerciseChoices;
    private explainStructureDecisions;
    private explainCustomizations;
    private explainRiskMitigation;
}
